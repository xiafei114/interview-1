1. 递归需要满足的三个条件
   - 一个问题可以分解为几个子问题的解
   - 这个问题被分解为子问题后，除了数据规模的不同，求解思路完全一致
   - 存在递归终止条件



举例: 假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

有两种走发，第一次可以选择一个台阶，也可以选择两个台阶, 最后剩余n-1个或者n-2个台阶,

所以求解n个台阶的走法，可以抽象为求解n-1个台阶的走法加n-2个台阶的走法

```go
f(n) = f(n-1) + f(n-2)
```

寻找终止条件, 当有一个台阶的时候，只有一种走发，贼f(1)=1, 两个台阶的走法有两种，f(2) 有走两次一阶或者走一次两阶的走法, 所以f(2) = 2

```
f(1)=1
f(2)=2
...
f(n) = f(n-1) + f(n-2)
```

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码

2. 递归代码要警惕堆栈溢出

   函数调用会使用栈来保存临时变量,当栈的深度达到一定的规模, 有一定的概率会导致堆栈溢出, 因此在一般情况下，会限制栈的深度来防止溢出, 但是很多场景下无法预估递归的深度, 这种方式不一定可行

3. 递归代码防止重复计算

   递归的计算能够被分解为一颗树, 树中的某些节点f(k)可能在计算过程中重复出现多次

![img](https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg)

因此可以通过建立散列表的方式来存储计算过的值, 当有重复计算的值时,O(1)时间复杂度就可以确认当前节点是否重复计算, 减轻计算压力

4. 时间复杂度与空间复杂度的损失
5. 尝试将递归代码改造为非递归代码

