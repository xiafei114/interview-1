# 1. httpCode 的响应码 
301: 永久重定向
302: 临时重定向
304: 内容未修改
400: 错误请求, 服务器不理解的请求
401: 未授权
403: 服务器拒绝请求
404: 网页找不到
405: 禁用请求中指定的方法
500: 服务器内部错误
502: 服务器作为网关或代理，从上游服务器收到无效响应
503: 服务器目前无法使用（由于超载或停机维护）
504: 服务器作为网关或代理，但是没有及时从上游服务器收到请求



# 2. ps 指令 

进程状态: 
    - D 不可中断 uninterruptible sleep
    - R 运行 running 
    - S 中断 sleeping
    - T 停止 traced or stopped
    - Z 僵死 a defunct("zombie") process

a: 显示所有进程, 包括其他用户的程序
-a: 显示所有进程，除了自己session下的进程
f: 用ASCII字符显示树状结构, 表达程序间的相互关系
u: 以用户为主的格式显示程序状况

常用指令:
ps aux

#3. 隔离级别 脏读幻读


#4. cpu,内存指标正常的情况下，怎么查询问题
等待磁盘io完成的进程过多
 - 磁盘读写请求过多导致大量IO等待
 - MySQL中存在没有用到的慢查询语句或死锁
 - 外接硬盘故障
 
CPU的工作效率要高于磁盘，而进程在CPU上面运行需要访问磁盘文件，这个时候CPU会向内核发起调用文件的请求，让内核去磁盘取文件，这个时候会切换到其他进程或者空闲，这个任务就会转换为不可中断睡眠状态。当这种读写请求过多就会导致不可中断睡眠状态的进程过多，从而导致负载高，CPU低的情况。
MySQL的数据是存储在硬盘中，如果需进行sql查询，要先把数据从磁盘加载到内存中。当在数据特别大的时候，如果执行的sql语句没有索引，就会造成扫描表的行数过大导致I/O阻塞，或者是语句中存在死锁，也会造成I/O阻塞，从而导致不可中断睡眠进程过多，导致负载过大。


内存使用:
   free -h 
   cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到加快访问速度的作用;
   buffer 的主要目的进行流量整理，把突发的大数量小规模的I/O」整理成平稳的「小数量较大规模的 I/O」，以减少响应次数。


```
    // 检查各类状态的tcp连接数的数量
    netstat -an | awk '/^tcp/ {++state[$NF]} END {for(a in state) print a, state[a]}'
```


# 5. nginx slow-log
request_slowlog_timeout=5s
slowlog=XXX


6. 两个大文件的排序去重 
sort    
    -o: 输出到文件中
    -g: 按照数字去排序
    -u: 去重
    -m: 合并有序的文件
    -T: 指定用来排序的临时空间, 而不是使用/tmp

uniq
    -c: 列出重复了多少次
    -d: 取出重复的行    

7. http1.0/1.1/2 的差异
# 8. 字符串的全排列, 两个链表是否有交叉, 二叉树的序列化

 - 链表是否有交叉
    方法一: 将两个链表拼接起来，判断是否有环'
    方法二: 将长的链表挪到跟短链表一样的长度, 在对两个链表进行比较是否存在交叉
    
 



9. 假设有100台机器, 其中n台机器异常，怎么排查问题
10. 跨站脚本攻击,  SQL注入等问题的原理以及解决方案
11. golang和php的优缺点
12. go module 怎么拉取私服的包
13. gitlab-ci 多个stage 之间怎么传递文件
14. http中header头 chunk的作用
15. http中Content-type = 200, 实际内容只有100, 浏览器会有怎样的表现

#16. root用户什么情况下无法删除某个文件
文件中带有 i或者a的属性 a表示只能添加内容不能删除内容, i表示不能删除改名
lsattr 
chattr +x(-x) 命令来增加或者移除对应的属性


17. trait 和 继承之间的差异
18. php ob缓存